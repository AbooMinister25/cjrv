{"plagiarized": [{"id": "744fc37c-3a54-4b7c-91f1-b53c7c5f7901", "user": {"username": "aditheawesome", "id": "379763992664473601", "discriminator": "0", "avatar": "a9b84afb7402f3c1696f6a8fd722a808", "bot": null, "system": null, "locale": null, "verified": null, "email": null, "flags": 64, "premium_type": null, "public_flags": 64, "admin": false}, "antispam": {"ip_hash": "87264dcbc451a2014da3cb23f1db7ff9", "user_agent_hash": "3b8d399b56fb9df5592b051fde36c903", "captcha_pass": false}, "response": {"age-range": "13-17 years old", "timezone-explainer": false, "timezone": "-4", "python-experience": "I'm OK, I've done a few projects in Python that are not related to courses or tutorials", "git-experience": "I'm pretty familiar with Git and use it regularly", "team-leader": "No", "code-jam-experience": "Yes", "qualifier-text": false, "qualifier": {"value": "from PIL import Image\n\ndef valid_input(image_size: tuple[int, int], tile_size: tuple[int, int], ordering: list[int]) -> bool:\n    \"\"\"\n    Return True if the given input allows the rearrangement of the image, False otherwise.\n\n    The tile size must divide each image dimension without remainders, and `ordering` must use each input tile exactly\n    once.\n    \"\"\"\n    # print(image_size[0], image_size[1])\n    # print(tile_size[0], tile_size[1])\n    return (image_size[0] % tile_size[0] == 0 and image_size[1] % tile_size[1] == 0 and len(ordering) == (image_size[0] // tile_size[0]) * (image_size[1] // tile_size[1]) and sorted(ordering) == list(range(len(ordering))))\n\n\ndef rearrange_tiles(image_path: str, tile_size: tuple[int, int], ordering: list[int], out_path: str) -> None:\n    \"\"\"\n    Rearrange the image.\n\n    The image is given in `image_path`. Split it into tiles of size `tile_size`, and rearrange them by `ordering`.\n    The new image needs to be saved under `out_path`.\n\n    The tile size must divide each image dimension without remainders, and `ordering` must use each input tile exactly\n    once. If these conditions do not hold, raise a ValueError with the message:\n    \"The tile size of ordering are not valid for the given image\".\n    \"\"\"\n    \n    image = Image.open(image_path)\n    if not valid_input(image.size, tile_size, ordering):\n        raise ValueError(\"The tile size or ordering are not valid for the given image\")\n    tileheight, tilewidth = tile_size\n    finalimg = Image.new(image.mode, image.size)\n    tilesperrow = int(image.size[0]/tilewidth)\n    for j in range(len(ordering)):\n        i = ordering[j]\n        w, h = i % tilesperrow, int(i/tilesperrow)\n        tile = image.crop((w*tilewidth, h*tileheight, (w+1)*tilewidth, (h+1)*tileheight))\n        finalimg.paste(tile, ((j % tilesperrow) * tilewidth, int(j/tilesperrow) * tileheight))\n    finalimg.save(out_path)", "passed": true, "failures": []}}, "form_id": "cj10-2023-qualifier", "timestamp": "2023-08-16T19:28:20.024634+00:00"}], "generated": [{"id": "6722cde6-74d2-44ed-8436-1d966bce15fc", "user": {"username": "399.", "id": "467435887236612106", "discriminator": "0", "avatar": "4eaa47803ea2b3907b2b3f1219e57a2d", "bot": null, "system": null, "locale": "en-US", "verified": null, "email": null, "flags": 0, "premium_type": 0, "public_flags": 0, "admin": false}, "antispam": {"ip_hash": "c216a8639e9ba59dc8fda48808d713e5", "user_agent_hash": "15c2f6f9416d00cec8b4f729460293c0", "captcha_pass": false}, "response": {"age-range": "25-34 years old", "timezone-explainer": false, "timezone": "+2", "python-experience": "I have considerable experience with the language, and have possible worked with it professionally for several years", "git-experience": "I'm pretty familiar with Git and use it regularly", "team-leader": "No", "code-jam-experience": "No", "qualifier-text": false, "qualifier": {"value": "import numpy as np\nfrom PIL import Image\n\ndef valid_input(image_size: tuple[int, int], tile_size: tuple[int, int], \n                ordering: list[int]) -> bool:\n    qc, rc = divmod(image_size[1], tile_size[1])\n    qr, rr = divmod(image_size[0], tile_size[0])\n    if rr != 0: #if rows not divisible\n        return False\n    if rc != 0: #if cols not divisible\n        return False\n    if len(np.unique(ordering)) != len(ordering) or len(ordering) != qc*qr:\n        return False    \n    return True\n\ndef rearrange_tiles(image_path: str, tile_size: tuple[int, int], \n                    ordering: list[int], out_path: str) -> None:\n    original = np.array(Image.open(image_path))\n    image_size = (original.shape[0], original.shape[1])\n    if not valid_input(image_size, tile_size, ordering):\n        raise ValueError(\n            \"The tile size of ordering are not valid for the given image\")\n    N_c_tiles = int(image_size[1]/tile_size[1])\n    ordering = np.array(ordering)\n    r_tiles, c_tiles = np.divmod(ordering, N_c_tiles)\n    \n    new = np.zeros(original.shape)\n    for t, (r_tile, c_tile) in enumerate(zip(r_tiles, c_tiles)):\n        o_r_tile, o_c_tile = divmod(t, N_c_tiles)\n        r0 = o_r_tile*tile_size[0]\n        c0 = o_c_tile*tile_size[1]\n        r1 = r_tile*tile_size[0]\n        c1 = c_tile*tile_size[1]\n        \n        new[r0:r0+tile_size[0], c0:c0+tile_size[1], :] = \\\n            original[r1:r1+tile_size[0], c1:c1+tile_size[1], :]\n    \n    new = Image.fromarray(new.astype(np.uint8))\n    new.save(out_path)    \n", "passed": true, "failures": []}}, "form_id": "cj10-2023-qualifier", "timestamp": "2023-08-12T21:48:37.786381+00:00"}]}